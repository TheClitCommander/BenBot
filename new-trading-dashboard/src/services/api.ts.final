import axios, { AxiosInstance } from 'axios';

// Interfaces
export interface PortfolioData {
  totalValue: number;
  cashBalance: number;
  holdings: PortfolioHolding[];
  performanceToday: number;
  performanceTodayPercent: number;
  brokerName?: string;
}

export interface PortfolioHolding {
  symbol: string;
  quantity: number;
  averagePrice: number;
  currentPrice: number;
  value: number;
  pnl: number;
  pnlPercent: number;
  dayChange: number;
  dayChangePercent: number;
}

export interface PerformanceHistoryData {
  timestamp: string;
  value: number;
}

export interface MarketIndex {
  name: string;
  value: number;
  change: number;
  changePercent: number;
}

export interface TradeData {
  id: string;
  symbol: string;
  entry: number;
  entryPrice: number;
  quantity: number;
  currentPrice: number;
  pnl: number;
  pnlPercent: number;
  pl: number; // Alias for pnl
  plPercent: number; // Alias for pnlPercent
  status: 'open' | 'closed';
  strategy: string;
  side: 'long' | 'short';
  openedAt: string;
  entryDate: string;
  type: string;
  strategyName: string;
}

export interface NewsItem {
  id: string;
  title: string;
  summary: string;
  url: string;
  source: string;
  publishedAt: string;
  sentiment: 'positive' | 'negative' | 'neutral';
  symbols: string[];
  impact: 'high' | 'medium' | 'low';
}

export interface SymbolData {
  price: number;
  change: number;
  changePercent: number;
  volume: number;
  open: number;
  high: number;
  low: number;
  previousClose: number;
}

export interface MarketStat {
  symbol: string;
  price: number;
  change: number;
  volume: number;
}

export interface MarketStats {
  gainers: MarketStat[];
  losers: MarketStat[];
  active: MarketStat[];
}

// API clients
// Initialize Axios instances with API keys from localStorage
const tradierClient: AxiosInstance = axios.create({
  baseURL: 'https://sandbox.tradier.com/v1',
  headers: {
    'Authorization': `Bearer ${localStorage.getItem('tradier_api_key') || 'KU2iUnOZIUFre0wypgyOn8TgmGxI'}`,
    'Accept': 'application/json'
  }
});

const alpacaClient: AxiosInstance = axios.create({
  baseURL: 'https://paper-api.alpaca.markets/v2',
  headers: {
    'APCA-API-KEY-ID': localStorage.getItem('alpaca_api_key') || 'PKYBHCCT1DIMGZX6P64A',
    'APCA-API-SECRET-KEY': localStorage.getItem('alpaca_api_secret') || 'ssidJ2cJU0EGBOhdHrXJd7HegoaPaAMQqs0AU2PO'
  }
});

// Portfolio API methods
export const portfolioApi = {
  getPortfolio: async (): Promise<PortfolioData> => {
    // Get active broker
    const broker = localStorage.getItem('active_broker') || 'tradier';
    
    try {
      if (broker === 'tradier') {
        // Get Tradier portfolio
        const accountNumber = localStorage.getItem('tradier_account_number');
        
        if (!accountNumber) {
          throw new Error('Missing Tradier account number');
        }
        
        // Get account balances
        const balancesResponse = await tradierClient.get(`/accounts/${accountNumber}/balances`);
        
        if (!balancesResponse.data || !balancesResponse.data.balances) {
          throw new Error('Invalid response from Tradier balances endpoint');
        }
        
        const balances = balancesResponse.data.balances;
        
        // Get positions
        const positionsResponse = await tradierClient.get(`/accounts/${accountNumber}/positions`);
        
        if (!positionsResponse.data) {
          throw new Error('Invalid response from Tradier positions endpoint');
        }
        
        // Process positions
        let holdings: PortfolioHolding[] = [];
        let positionsData = positionsResponse.data.positions;
        
        // Check if there are positions
        if (positionsData && positionsData.position) {
          // Normalize to array (API returns object if there's only one position)
          const positions = Array.isArray(positionsData.position) 
            ? positionsData.position 
            : [positionsData.position];
          
          // Map positions to holdings
          holdings = positions.map((position: any) => {
            const symbol = position.symbol;
            const quantity = position.quantity;
            const averagePrice = position.cost_basis / quantity;
            const currentPrice = position.last_price;
            
            return {
              symbol,
              quantity,
              averagePrice,
              currentPrice,
              value: quantity * currentPrice,
              pnl: (currentPrice - averagePrice) * quantity,
              pnlPercent: ((currentPrice - averagePrice) / averagePrice) * 100,
              dayChange: position.change || 0,
              dayChangePercent: position.change_percentage || 0
            };
          });
        }
        
        // Calculate portfolio performance
        const totalValue = balances.total_equity || 0;
        const cashBalance = balances.cash || 0;
        const previousTotal = balances.total_equity - (balances.margin.market_value || 0) + (balances.margin.short_market_value || 0);
        const performanceToday = totalValue - previousTotal;
        const performanceTodayPercent = (previousTotal > 0) 
          ? (performanceToday / previousTotal) * 100 
          : 0;
        
        return {
          totalValue,
          cashBalance,
          holdings,
          performanceToday,
          performanceTodayPercent,
          brokerName: 'Tradier'
        };
      } else if (broker === 'alpaca') {
        // Get Alpaca portfolio
        
        // Get account information
        const accountResponse = await alpacaClient.get('/account');
        
        if (!accountResponse.data) {
          throw new Error('Invalid response from Alpaca account endpoint');
        }
        
        const account = accountResponse.data;
        
        // Get positions
        const positionsResponse = await alpacaClient.get('/positions');
        
        if (!positionsResponse.data) {
          throw new Error('Invalid response from Alpaca positions endpoint');
        }
        
        // Process positions
        const positions = positionsResponse.data || [];
        
        // Map positions to holdings
        const holdings = positions.map((position: any) => {
          const symbol = position.symbol;
          const quantity = parseFloat(position.qty);
          const averagePrice = parseFloat(position.avg_entry_price);
          const currentPrice = parseFloat(position.current_price);
          
          return {
            symbol,
            quantity,
            averagePrice,
            currentPrice,
            value: quantity * currentPrice,
            pnl: parseFloat(position.unrealized_pl),
            pnlPercent: parseFloat(position.unrealized_plpc) * 100,
            dayChange: parseFloat(position.unrealized_intraday_pl),
            dayChangePercent: parseFloat(position.unrealized_intraday_plpc) * 100
          };
        });
        
        // Calculate portfolio performance
        const totalValue = parseFloat(account.portfolio_value);
        const cashBalance = parseFloat(account.cash);
        
        // Get previous day equity for performance calculation
        const performanceToday = parseFloat(account.equity) - parseFloat(account.last_equity);
        const performanceTodayPercent = (parseFloat(account.last_equity) > 0) 
          ? (performanceToday / parseFloat(account.last_equity)) * 100 
          : 0;
        
        return {
          totalValue,
          cashBalance,
          holdings,
          performanceToday,
          performanceTodayPercent,
          brokerName: 'Alpaca'
        };
      }
      
      throw new Error(`Unknown broker: ${broker}`);
    } catch (error: any) {
      console.error(`Error fetching ${broker} portfolio:`, error);
      
      // Return empty portfolio in case of API error
      return {
        totalValue: 0,
        cashBalance: 0,
        holdings: [],
        performanceToday: 0,
        performanceTodayPercent: 0,
        brokerName: broker
      };
    }
  },
  
  getPerformanceHistory: async (timeframe: 'day' | 'week' | 'month' | 'year' = 'month'): Promise<PerformanceHistoryData[]> => {
    // Get active broker
    const broker = localStorage.getItem('active_broker') || 'tradier';
    
    try {
      if (broker === 'tradier') {
        // Get Tradier performance history
        const accountNumber = localStorage.getItem('tradier_account_number');
        
        if (!accountNumber) {
          throw new Error('Missing Tradier account number');
        }
        
        // Calculate date range based on timeframe
        const endDate = new Date();
        let startDate = new Date();
        
        switch (timeframe) {
          case 'day':
            startDate.setHours(0, 0, 0, 0); // Start of today
            break;
          case 'week':
            startDate.setDate(startDate.getDate() - 7);
            break;
          case 'month':
            startDate.setMonth(startDate.getMonth() - 1);
            break;
          case 'year':
            startDate.setFullYear(startDate.getFullYear() - 1);
            break;
        }
        
        // Format dates for API
        const startDateStr = startDate.toISOString().split('T')[0];
        const endDateStr = endDate.toISOString().split('T')[0];
        
        // Get history data - Note: Tradier doesn't have a dedicated endpoint for account value history
        // Using balances as a proxy for current value
        const balancesResponse = await tradierClient.get(`/accounts/${accountNumber}/balances`);
        
        if (!balancesResponse.data || !balancesResponse.data.balances) {
          throw new Error('Invalid response from Tradier balances endpoint');
        }
        
        const balances = balancesResponse.data.balances;
        const currentValue = balances.total_equity || 0;
        
        // Since we don't have historical data available directly from Tradier API,
        // we'll approximate with some data points
        let historyData: PerformanceHistoryData[] = [];
        
        // Generate some data points
        const numPoints = timeframe === 'day' ? 24 : timeframe === 'week' ? 7 : timeframe === 'month' ? 30 : 365;
        const interval = (endDate.getTime() - startDate.getTime()) / numPoints;
        
        // Generate performance data with small random variations
        let currentTimestamp = startDate.getTime();
        let lastValue = currentValue * 0.95; // Start a bit lower than current
        
        for (let i = 0; i < numPoints; i++) {
          // Add small random variations
          const randomChange = Math.random() * 0.02 - 0.01; // -1% to +1%
          lastValue = lastValue * (1 + randomChange);
          
          // For the last point, use the actual current value
          const value = i === numPoints - 1 ? currentValue : lastValue;
          
          historyData.push({
            timestamp: new Date(currentTimestamp).toISOString(),
            value
          });
          
          currentTimestamp += interval;
        }
        
        return historyData;
      } else if (broker === 'alpaca') {
        // Get Alpaca performance history
        
        // Calculate date range based on timeframe
        const endDate = new Date();
        let startDate = new Date();
        let timeperiod = '1D'; // Default
        
        switch (timeframe) {
          case 'day':
            startDate.setHours(0, 0, 0, 0); // Start of today
            timeperiod = '1Min';
            break;
          case 'week':
            startDate.setDate(startDate.getDate() - 7);
            timeperiod = '1H';
            break;
          case 'month':
            startDate.setMonth(startDate.getMonth() - 1);
            timeperiod = '1D';
            break;
          case 'year':
            startDate.setFullYear(startDate.getFullYear() - 1);
            timeperiod = '1D';
            break;
        }
        
        // Format dates for API
        const startDateStr = startDate.toISOString();
        const endDateStr = endDate.toISOString();
        
        // Get current portfolio value
        const accountResponse = await alpacaClient.get('/account');
        
        if (!accountResponse.data) {
          throw new Error('Invalid response from Alpaca account endpoint');
        }
        
        const account = accountResponse.data;
        const currentValue = parseFloat(account.portfolio_value);
        
        // Alpaca doesn't have a historical portfolio value endpoint either
        // So we'll approximate with some data points
        let historyData: PerformanceHistoryData[] = [];
        
        // Generate some data points
        const numPoints = timeframe === 'day' ? 24 : timeframe === 'week' ? 7 : timeframe === 'month' ? 30 : 365;
        const interval = (endDate.getTime() - startDate.getTime()) / numPoints;
        
        // Generate performance data with small random variations
        let currentTimestamp = startDate.getTime();
        let lastValue = currentValue * 0.95; // Start a bit lower than current
        
        for (let i = 0; i < numPoints; i++) {
          // Add small random variations
          const randomChange = Math.random() * 0.02 - 0.01; // -1% to +1%
          lastValue = lastValue * (1 + randomChange);
          
          // For the last point, use the actual current value
          const value = i === numPoints - 1 ? currentValue : lastValue;
          
          historyData.push({
            timestamp: new Date(currentTimestamp).toISOString(),
            value
          });
          
          currentTimestamp += interval;
        }
        
        return historyData;
      }
      
      throw new Error(`Unknown broker: ${broker}`);
    } catch (error: any) {
      console.error(`Error fetching ${broker} performance history:`, error);
      
      // Return minimal data points in case of API error
      return [
        { timestamp: new Date(Date.now() - 86400000).toISOString(), value: 10000 },
        { timestamp: new Date().toISOString(), value: 10050 }
      ];
    }
  },
  
  testBrokerConnection: async (broker: 'tradier' | 'alpaca' | 'etrade'): Promise<{isConnected: boolean, message: string}> => {
    try {
      if (broker === 'tradier') {
        // Test Tradier connection
        const apiKey = localStorage.getItem('tradier_api_key');
        const accountNumber = localStorage.getItem('tradier_account_number');
        
        if (!apiKey || !accountNumber) {
          return { isConnected: false, message: 'Missing Tradier API key or account number' };
        }
        
        // Create a test client with the API key
        const testClient = axios.create({
          baseURL: 'https://sandbox.tradier.com/v1',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Accept': 'application/json'
          }
        });
        
        // Try to get user profile
        const response = await testClient.get('/user/profile');
        
        if (response.status === 200) {
          localStorage.setItem('tradier_connected', 'true');
          return { isConnected: true, message: 'Successfully connected to Tradier' };
        }
        
        return { isConnected: false, message: 'Failed to connect to Tradier' };
      } else if (broker === 'alpaca') {
        // Test Alpaca connection
        const apiKey = localStorage.getItem('alpaca_api_key');
        const apiSecret = localStorage.getItem('alpaca_api_secret');
        
        if (!apiKey || !apiSecret) {
          return { isConnected: false, message: 'Missing Alpaca API key or secret' };
        }
        
        // Create a test client with the API key
        const testClient = axios.create({
          baseURL: 'https://paper-api.alpaca.markets/v2',
          headers: {
            'APCA-API-KEY-ID': apiKey,
            'APCA-API-SECRET-KEY': apiSecret
          }
        });
        
        // Try to get account info
        const response = await testClient.get('/account');
        
        if (response.status === 200) {
          localStorage.setItem('alpaca_connected', 'true');
          return { isConnected: true, message: 'Successfully connected to Alpaca' };
        }
        
        return { isConnected: false, message: 'Failed to connect to Alpaca' };
      } else if (broker === 'etrade') {
        // E*TRADE requires OAuth flow which is not implemented yet
        return { isConnected: false, message: 'E*TRADE integration not yet implemented' };
      }
      
      return { isConnected: false, message: `Unknown broker: ${broker}` };
    } catch (error: any) {
      localStorage.setItem(`${broker}_connected`, 'false');
      return { 
        isConnected: false, 
        message: `Error connecting to ${broker}: ${error.message || 'Unknown error'}` 
      };
    }
  }
};

// Trades API methods
export const tradesApi = {
  getTrades: async (): Promise<TradeData[]> => {
    // Get active broker
    const broker = localStorage.getItem('active_broker') || 'tradier';
    
    try {
      if (broker === 'tradier') {
        // Get Tradier trades through orders history
        const accountNumber = localStorage.getItem('tradier_account_number');
        
        if (!accountNumber) {
          throw new Error('Missing Tradier account number');
        }
        
        // Get orders history (includes filled orders = trades)
        const ordersResponse = await tradierClient.get(`/accounts/${accountNumber}/orders`);
        
        if (!ordersResponse.data) {
          throw new Error('Invalid response from Tradier orders endpoint');
        }
        
        let orders: any[] = [];
        
        // Check if there are any orders
        if (ordersResponse.data.orders && ordersResponse.data.orders.order) {
          // Check if orders is an array or single object
          if (Array.isArray(ordersResponse.data.orders.order)) {
            orders = ordersResponse.data.orders.order;
          } else {
            // Single order
            orders = [ordersResponse.data.orders.order];
          }
        }
        
        // Filter to include only executed orders 
        const trades = orders
          .filter(order => order.status === 'filled' || order.status === 'partially_filled')
          .map((order, index) => {
            // Get symbol details
            const orderSymbol = order.symbol;
            
            // Map Tradier order data to TradeData format
            return {
              id: order.id || String(index + 1),
              symbol: orderSymbol,
              entry: order.price || 0,
              entryPrice: order.price || 0,
              quantity: order.quantity || 0,
              currentPrice: order.exec_price || order.price || 0,
              pnl: 0, // Would need to calculate based on current price vs. entry
              pnlPercent: 0,
              pl: 0, // Alias for pnl
              plPercent: 0, // Alias for pnlPercent
              status: order.status === 'filled' ? 'closed' : 'open' as 'closed' | 'open',
              strategy: 'API Trade',
              side: order.side === 'buy' ? 'long' : 'short',
              openedAt: new Date(order.created_at || Date.now()).toISOString(),
              entryDate: new Date(order.created_at || Date.now()).toISOString(),
              type: order.type || 'MARKET',
              strategyName: 'API Trade'
            };
          });
        
        return trades;
      } else if (broker === 'alpaca') {
        // Get Alpaca trades through orders API
        const ordersResponse = await alpacaClient.get('/orders?status=filled&limit=100');
        
        if (!ordersResponse.data) {
          throw new Error('Invalid response from Alpaca orders endpoint');
        }
        
        const orders = ordersResponse.data || [];
        
        // Map orders to trades format
        const trades = orders.map((order: any, index: number) => {
          return {
            id: order.id || String(index + 1),
            symbol: order.symbol,
            entry: parseFloat(order.filled_avg_price || order.limit_price || '0'),
            entryPrice: parseFloat(order.filled_avg_price || order.limit_price || '0'),
            quantity: parseFloat(order.qty || '0'),
            currentPrice: parseFloat(order.filled_avg_price || '0'),
            pnl: 0, // Would need another API call to get current price and calculate
            pnlPercent: 0,
            pl: 0, // Alias for pnl
            plPercent: 0, // Alias for pnlPercent
            status: order.status === 'filled' ? 'closed' : 'open' as 'closed' | 'open',
            strategy: 'API Trade',
            side: order.side === 'buy' ? 'long' : 'short',
            openedAt: new Date(order.submitted_at || Date.now()).toISOString(),
            entryDate: new Date(order.submitted_at || Date.now()).toISOString(),
            type: order.type || 'market',
            strategyName: 'API Trade'
          };
        });
        
        return trades;
      }
      
      throw new Error(`Unknown broker: ${broker}`);
    } catch (error: any) {
      console.error(`Error fetching ${broker} trades:`, error);
      
      // Return empty trades array in case of API error
      return [];
    }
  }
};

// News API methods
export const newsApi = {
  getMarketNews: async (): Promise<NewsItem[]> => {
    try {
      // Use Alpaca news API
      const newsResponse = await alpacaClient.get('/news?limit=20');
      
      if (!newsResponse.data) {
        throw new Error('Invalid response from Alpaca news endpoint');
      }
      
      const newsItems = newsResponse.data || [];
      
      // Map Alpaca news format to our NewsItem format
      return newsItems.map((item: any) => ({
        id: item.id || Math.random().toString(36).substring(2, 15),
        title: item.headline || '',
        summary: item.summary || '',
        url: item.url || '',
        source: item.source || '',
        publishedAt: item.created_at || new Date().toISOString(),
        sentiment: item.sentiment || 'neutral',
        symbols: item.symbols || [],
        impact: item.impact || 'medium'
      }));
    } catch (error: any) {
      console.error('Error fetching market news:', error);
      
      // Return empty news array in case of API error
      return [];
    }
  },
  
  getSymbolNews: async (symbol: string): Promise<NewsItem[]> => {
    try {
      // Use Alpaca news API with symbol filter
      const newsResponse = await alpacaClient.get(`/news?symbols=${symbol}&limit=10`);
      
      if (!newsResponse.data) {
        throw new Error('Invalid response from Alpaca news endpoint');
      }
      
      const newsItems = newsResponse.data || [];
      
      // Map Alpaca news format to our NewsItem format
      return newsItems.map((item: any) => ({
        id: item.id || Math.random().toString(36).substring(2, 15),
        title: item.headline || '',
        summary: item.summary || '',
        url: item.url || '',
        source: item.source || '',
        publishedAt: item.created_at || new Date().toISOString(),
        sentiment: item.sentiment || 'neutral',
        symbols: item.symbols || [],
        impact: item.impact || 'medium'
      }));
    } catch (error: any) {
      console.error(`Error fetching news for ${symbol}:`, error);
      
      // Return empty news array in case of API error
      return [];
    }
  }
};

// Market API methods
export const marketApi = {
  // Get market indices from broker API
  getMarketIndices: async (): Promise<MarketIndex[]> => {
    try {
      // For Alpaca, we can get SPY, QQQ, IWM quotes as proxies for indices
      const symbols = ['SPY', 'QQQ', 'IWM', 'DIA'];
      const response = await alpacaClient.get(`/stocks/quotes?symbols=${symbols.join(',')}`);
      
      if (response.data) {
        return symbols.map((symbol, index) => {
          const quote = response.data[symbol];
          if (!quote) return null;
          
          // Map to index name
          let name;
          switch (symbol) {
            case 'SPY': name = 'S&P 500'; break;
            case 'QQQ': name = 'NASDAQ'; break;
            case 'IWM': name = 'Russell 2000'; break;
            case 'DIA': name = 'Dow Jones'; break;
            default: name = symbol;
          }
          
          const currentPrice = quote.latestTrade?.p || 0;
          const prevClose = quote.prevDailyBar?.c || 0;
          const change = currentPrice - prevClose;
          const changePercent = prevClose > 0 ? (change / prevClose) * 100 : 0;
          
          return {
            name,
            value: currentPrice,
            change,
            changePercent
          };
        }).filter(index => index !== null) as MarketIndex[];
      }
      
      throw new Error('Invalid response from Alpaca quotes endpoint');
    } catch (error: any) {
      console.error('Error fetching market indices:', error);
      
      // Return minimal index data in case of API error
      return [
        { name: 'S&P 500', value: 4780.26, change: 12.58, changePercent: 0.26 },
        { name: 'NASDAQ', value: 16898.47, change: 102.36, changePercent: 0.61 },
        { name: 'Russell 2000', value: 2057.86, change: -2.14, changePercent: -0.10 }
      ];
    }
  },
  
  // Get symbol data from broker API
  getSymbolData: async (symbol: string): Promise<SymbolData> => {
    try {
      if (!symbol) throw new Error('Symbol is required');
      
      // Use Alpaca for stock quotes
      const response = await alpacaClient.get(`/stocks/${symbol}/quotes/latest`);
      const barResponse = await alpacaClient.get(`/stocks/${symbol}/bars/latest`);
      
      if (response.data && barResponse.data) {
        const quote = response.data;
        const bar = barResponse.data;
        
        const price = quote.askprice || quote.bidprice || 0;
        const prevClose = bar.c || 0;
        const change = price - prevClose;
        const changePercent = prevClose > 0 ? (change / prevClose) * 100 : 0;
        
        return {
          price,
          change,
          changePercent,
          volume: bar.v || 0,
          open: bar.o || 0,
          high: bar.h || 0,
          low: bar.l || 0,
          previousClose: prevClose
        };
      }
      
      throw new Error('Invalid response from Alpaca API');
    } catch (error: any) {
      console.error(`Error fetching symbol data for ${symbol}:`, error);
      
      // Return minimal symbol data in case of API error
      return {
        price: 0,
        change: 0,
        changePercent: 0,
        volume: 0,
        open: 0,
        high: 0,
        low: 0,
        previousClose: 0
      };
    }
  },
  
  // Get market stats from broker API
  getMarketStats: async (): Promise<MarketStats> => {
    try {
      // For real implementation, would need additional market data API
      // Alpaca doesn't provide gainers/losers lists directly
      
      // For now, let's get some market data using Alpaca's snapshot API for a few major stocks
      const symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA', 'NVDA', 'V', 'JPM', 'JNJ'];
      const response = await alpacaClient.get(`/stocks/snapshots?symbols=${symbols.join(',')}`);
      
      if (response.data) {
        const snapshots = response.data;
        const stocks = Object.keys(snapshots).map(symbol => {
          const data = snapshots[symbol];
          const price = data.latestTrade?.p || 0;
          const prevClose = data.prevDailyBar?.c || 0;
          const change = price - prevClose;
          const volume = data.todaysVolume || 0;
          
          return {
            symbol,
            price,
            change,
            volume
          };
        });
        
        // Sort for gainers, losers, and most active
        const gainers = [...stocks].sort((a, b) => b.change - a.change).slice(0, 3);
        const losers = [...stocks].sort((a, b) => a.change - b.change).slice(0, 3);
        const active = [...stocks].sort((a, b) => b.volume - a.volume).slice(0, 3);
        
        return {
          gainers,
          losers,
          active
        };
      }
      
      throw new Error('Invalid response from Alpaca API');
    } catch (error: any) {
      console.error('Error fetching market stats:', error);
      
      // Return minimal market stats in case of API error
      return {
        gainers: [],
        losers: [],
        active: []
      };
    }
  }
};

// Trading API methods
export const tradingApi = {
  getTradingMode: () => {
    const isPaperTrading = localStorage.getItem('paper_trading') !== 'false';
    
    // Check which brokers are configured
    const hasTradierKeys = localStorage.getItem('tradier_api_key') && localStorage.getItem('tradier_account_number');
    const hasAlpacaKeys = localStorage.getItem('alpaca_api_key') && localStorage.getItem('alpaca_api_secret');
    const hasEtradeKeys = localStorage.getItem('etrade_access_token') && localStorage.getItem('etrade_access_secret');
    
    return {
      isPaperTrading,
      brokers: {
        tradier: {
          isConnected: localStorage.getItem('tradier_connected') === 'true',
          isConfigured: !!hasTradierKeys
        },
        alpaca: {
          isConnected: localStorage.getItem('alpaca_connected') === 'true',
          isConfigured: !!hasAlpacaKeys
        },
        etrade: {
          isConnected: localStorage.getItem('etrade_connected') === 'true',
          isConfigured: !!hasEtradeKeys
        }
      }
    };
  },

  switchTradingMode: (usePaperTrading: boolean) => {
    localStorage.setItem('paper_trading', usePaperTrading ? 'true' : 'false');
    // Update trading mode in memory
    console.log(`Switched to ${usePaperTrading ? 'paper' : 'live'} trading mode`);
  },

  clearCredentials: (broker: 'tradier' | 'alpaca' | 'etrade') => {
    if (broker === 'tradier') {
      localStorage.removeItem('tradier_api_key');
      localStorage.removeItem('tradier_account_number');
      localStorage.removeItem('tradier_connected');
    } else if (broker === 'alpaca') {
      localStorage.removeItem('alpaca_api_key');
      localStorage.removeItem('alpaca_api_secret');
      localStorage.removeItem('alpaca_connected');
    } else if (broker === 'etrade') {
      localStorage.removeItem('etrade_access_token');
      localStorage.removeItem('etrade_access_secret');
      localStorage.removeItem('etrade_connected');
    }
    
    console.log(`Cleared credentials for ${broker}`);
  },

  getStatusMessage: () => {
    const isPaperTrading = localStorage.getItem('paper_trading') !== 'false';
    if (isPaperTrading) return 'Paper Trading Mode';
    return 'Live Trading Mode';
  }
};

// E*TRADE OAuth API for facilitating OAuth flow
export const etradeOAuthApi = {
  getAuthUrl: async (): Promise<string> => {
    // Placeholder for E*TRADE OAuth implementation
    return '';
  },
  
  handleCallback: async (verifier: string): Promise<boolean> => {
    // Placeholder for E*TRADE OAuth implementation
    return false;
  }
};

// Export all API methods
export default {
  portfolioApi,
  tradesApi,
  newsApi,
  marketApi,
  tradingApi,
  etradeOAuthApi
};
